#include<bits/stdc++.h>
#include<windows.h>
namespace IO
{
	FILE * In;
	inline void IO(const char * name){In=fopen(name,"w+");}
	template<typename T>
	inline char * Insert_num(char * c,T x)
	{
		int len=-1;
		if(x==0)c[len=0]='0';
		while(x)
		{
			c[++len]=x%10+'0';
			x/=10;
		}
		for(int i=0,j=len;i<j;i++,j--)std::swap(c[i],c[j]);
		return c+len+1;
	}
	template<typename T1,typename ...T2>
	inline void IO(const char * name,T1 x,T2 ... arg)
	{
		static char new_name[105];
		std::memset(new_name,0,sizeof(new_name));
		char * i=new  char[strlen(name)+3];
		strcpy(i,name);
		char * j=new_name;
		for(;*i!='\0'&&(*i!='%'||*(i+1)!='d');i++,j++)*j=*i;
		if(*i=='\0')return fprintf(stdout,"error!the parameters are too much!"),IO(name),void();
		j=Insert_num(j,x);
		i=i+2;
		for(;*i!='\0';i++,j++)*j=*i;
//		fprintf(stdout,"%s\n",new_name);
		IO((const char *)new_name,arg...);
	}
}
namespace Rand
{
	template<typename T>inline T random(){return (T)rand()*rand()*rand();}
	template<typename T>inline T random(T p){return (random<T>()%p+p)%p+1;}
	template<typename T1,typename T2>inline T1 random(T1 lower,T2 upper){return lower+random(upper-lower+1)-1;}
}
namespace Pair
{
	template<typename T>inline std::pair<T,T>Pair(T p)
	{
		std::pair<T,T>re=std::make_pair(Rand::random(p),Rand::random(p));
		while(re.first<=re.second)re=std::make_pair(Rand::random(p),Rand::random(p));
		return re;
	}
	template<typename T>inline void Print(std::pair<T,T> re,char c='\n'){fprintf(IO::In,"%lld %lld%c",(long long)re.first,(long long)re.second,c);}
}
namespace Vector
{
	template<typename T>std::vector<T> Vector(std::vector<T>lower,std::vector<T>upper)
	{
		if(lower.size()!=upper.size())
		{
			fprintf(stdout,"error!the parameters are different!\n");
			return {};
		}
		std::vector<T> re;
		for(int i=0;i<lower.size();i++)
			re.push_back(Rand::random(lower[i],upper[i]));
		return re;
	}
	template<typename T>inline void Print(std::vector<T> re,char c='\n')
	{
		for(auto i:re)fprintf(IO::In,"%lld ",(long long)i);
		fprintf(IO::In,"%c",c);
	}
}
namespace UFS
{
	template<int T>
	struct UFS
	{
		int fa[T];
		UFS(){for(int i=0;i<T;i++)fa[i]=i;}
		inline int find(int x){if(fa[x]==x)return x;return fa[x]=find(fa[x]);}
		inline void merge(int x,int y){int fat=find(x),fbt=find(y);fa[fat]=fbt;}
		inline bool IsSplit(int x,int y){return find(x)!=find(y);}
	};
}
namespace Tree
{
	inline std::vector<std::pair<int,int> > Tree(int n)
	{
		UFS::UFS<1000005> S;
		std::vector<std::pair<int,int> > re;
		for(int i=2;i<=n;i++)
		{
			for(;;)
			{
				int fa=Rand::random(n);
				if(S.IsSplit(i,fa))
				{
					S.merge(i,fa);
					re.push_back(std::make_pair(fa,i));
					break;
				}
			}
		}
		return re;
	}
}
namespace Atlas
{
	std::map<std::pair<int,int>,bool>mp;
	inline std::vector<std::pair<int,int> > Atlas(int n,int m)
	{
		if(m>n*(n-1)/2)
		{
			fprintf(stdout,"error!The edges are too much!\n");
			return {};
		}
		std::vector<std::pair<int,int> > re=Tree::Tree(n);
		for(int i=n;i<=m;i++)
		{
			for(;;)
			{
				std::pair<int,int> now=Pair::Pair(n);
				if(mp[now]==0)
				{
					mp[now]=0;
					re.push_back(now);
					break;
				}
			}
		}
		return re;
	}
}

