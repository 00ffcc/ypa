#include<bits/stdc++.h>
#include<windows.h>
namespace IO
{
	FILE * In;
	inline void IO(const char * name){In=fopen(name,"w+");srand(time(0)*clock()*1000);}
	template<typename T>
	inline char * Insert_num(char * c,T x)
	{
		int len=-1;
		if(x==0)c[len=0]='0';
		while(x)
		{
			c[++len]=x%10+'0';
			x/=10;
		}
		for(int i=0,j=len;i<j;i++,j--)std::swap(c[i],c[j]);
		return c+len+1;
	}
	template<typename T1,typename ...T2>
	inline void IO(const char * name,T1 x,T2 ... arg)
	{
		static char new_name[105];
		std::memset(new_name,0,sizeof(new_name));
		char * i=new  char[strlen(name)+3];
		strcpy(i,name);
		char * j=new_name;
		for(;*i!='\0'&&(*i!='%'||*(i+1)!='d');i++,j++)*j=*i;
		if(*i=='\0')return fprintf(stdout,"error!the parameters are too much!"),IO(name),void();
		j=Insert_num(j,x);
		i=i+2;
		for(;*i!='\0';i++,j++)*j=*i;
//		fprintf(stdout,"%s\n",new_name);
		IO((const char *)new_name,arg...);
	}
}
namespace Rand
{
	template<typename T>inline T random(){return (T)rand()*rand()*rand();}
	template<typename T>inline T random(T p){return (random<T>()%p+p)%p+1;}
	template<typename T1,typename T2>inline T1 random(T1 lower,T2 upper){return lower+random(upper-lower+1)-1;}
}
namespace Pair
{
	template<typename T>inline std::pair<T,T>Pair(T p)
	{
		std::pair<T,T>re=std::make_pair(Rand::random(p),Rand::random(p));
		while(re.first<=re.second)re=std::make_pair(Rand::random(p),Rand::random(p));
		return re;
	}
	template<typename T>inline void Print(std::pair<T,T> re,char c='\n'){fprintf(IO::In,"%lld %lld%c",(long long)re.first,(long long)re.second,c);}
}
namespace Vector
{
	template<typename T>std::vector<T> Vector(std::vector<T>lower,std::vector<T>upper)
	{
		if(lower.size()!=upper.size())
		{
			fprintf(stdout,"error!the parameters are different!\n");
			return {};
		}
		std::vector<T> re;
		for(int i=0;i<lower.size();i++)
			re.push_back(Rand::random(lower[i],upper[i]));
		return re;
	}
	template<typename T>inline void Print(std::vector<T> re,char c='\n')
	{
		for(auto i:re)fprintf(IO::In,"%lld ",(long long)i);
		fprintf(IO::In,"%c",c);
	}
}
namespace UFS
{
	template<int T>
	struct UFS
	{
		int fa[T];
		UFS(){for(int i=0;i<T;i++)fa[i]=i;}
		inline int find(int x){if(fa[x]==x)return x;return fa[x]=find(fa[x]);}
		inline void merge(int x,int y){int fat=find(x),fbt=find(y);fa[fat]=fbt;}
		inline bool IsSplit(int x,int y){return find(x)!=find(y);}
	};
}
namespace Tree
{
	inline std::vector<std::pair<int,int> > Tree(int n)
	{
		UFS::UFS<1000005> S;
		std::vector<std::pair<int,int> > re;
		for(int i=2;i<=n;i++)
		{
			for(;;)
			{
				int fa=Rand::random(n);
				if(S.IsSplit(i,fa))
				{
					S.merge(i,fa);
					re.push_back(std::make_pair(fa,i));
					break;
				}
			}
		}
		random_shuffle(re.begin(),re.end()); 
		return re;
	}
}
namespace Atlas
{
	inline std::vector<std::pair<int,int> > Atlas(int n,int m)
	{
		std::map<std::pair<int,int>,bool>mp;		
		if(m>n*(n-1)/2)
		{
			fprintf(stdout,"error!The edges are too much!\n");
			return {};
		}
		std::vector<std::pair<int,int> > re=Tree::Tree(n);
		for(int i=n;i<=m;i++)
		{
			for(;;)
			{
				std::pair<int,int> now=Pair::Pair(n);
				if(mp[now]==0)
				{
					mp[now]=0;
					re.push_back(now);
					break;
				}
			}
		}
		random_shuffle(re.begin(),re.end()); 
		return re;
	}
}
namespace Cactus
{
	inline std::vector<std::pair<int,int> >Circle(std::vector<int> cross)
	{
		if(cross.size()<=1)return {}; 
		std::vector<std::pair<int,int> > re;
		if(Rand::random<int>()&1)//简单环 
		{
			for(int i=0;i<cross.size()-1;i++)
				re.push_back(std::make_pair(cross[i],cross[i+1]));
			re.push_back(std::make_pair(*--cross.end(),*cross.begin()));
		}
		else//非简单环
		{
			random_shuffle(cross.begin(),cross.end());
			int last=1;
			for(int i=1;i<cross.size();i++)
			{
				if(Rand::random<int>()%7<=2||i==cross.size()-1)
				{
					re.push_back(std::make_pair(cross[0],cross[last]));
					re.push_back(std::make_pair(cross[0],cross[i]));
					for(int j=last;j<i;j++)
						re.push_back(std::make_pair(cross[j],cross[j+1]));
					last=i+1;
				}
			}
		}
//		printf("Circle\n");
//		for(auto i:re)printf("%d %d\n",i.first,i.second);
		random_shuffle(re.begin(),re.end());
		return re;
	}
	inline std::vector<std::pair<int,int> >Cactus(int n,int m)
	{
		static int belong[1000005];memset(belong,0,sizeof(belong));
		std::vector<int> cross[1000005];
		for(int i=1;i<=n;i++)belong[i]=Rand::random(n),cross[belong[i]].push_back(i);
/*		for(int i=1;i<=n;i++)printf("%d ",belong[i]);printf("\n");
		for(int i=1;i<=n;i++)
		{
			for(auto j:cross[i])
				fprintf(stdout,"%d ",j);
			fprintf(stdout,"\n");
		}*/
		std::vector<std::pair<int,int> > re;
		for(int i=1;i<=n;i++)
		{
			std::vector<std::pair<int,int> > tp=Circle(cross[i]);
			for(auto i:tp)re.push_back(i);
		}
		UFS::UFS<1000005> S;
		int cnt=0;
		for(int i=1;i<=n;i++)
			if(cross[i].size())
				cnt++;
		for(int i=1;i<cnt;i++)
		{
			for(int j=1;j<=10;j++)
			{
				std::pair<int,int> tp=Pair::Pair(n);
				if(S.IsSplit(belong[tp.first],belong[tp.second]))
				{
					S.merge(belong[tp.first],belong[tp.second]);
					re.push_back(std::make_pair(tp.first,tp.second));
					break;
				}		
			}
		}
		random_shuffle(re.begin(),re.end());
		while(re.size()>m)re.pop_back();
		return re;
	}
}

